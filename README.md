# L-R
L >> R


## A talk about shifting left and shifting right

### Abstract
As we all shift right into the future, looking back we can see cycles of invention and re-invention of the activities that contribute to delivering software products.
Shifting left is used in a few contexts in slightly different ways but they broadly share the idea that defining things earlier in the workflow is an unalloyed good. This process can happen via code:- C++ 26 for example has a reflection proposal and other mechanisms have been used previously. For other ecosystems, it's "the air you breathe" and pervasive. This process can also happen via tooling, which affects the way we work and interact. As a final thought, this process occurs at the collaboration level and design level, which nudges the way we end up producing our total system, the finished product.

In this talk we'll go consider a variety of technologies and we'll be able to look back quite far in time. We can then cherry-pick some illustrative examples which will allow us to discuss how our understanding and attitudes of what to shift left and what to shift right have changed. Mostly importantly, what will we do next, and why?


### Outline
Going back far enough, there are various strata. Strata where the dominant languages had almost no introspective capability, unless you rolled your own. There was an era of commercial software systems - some of which were pretty decent for defining software delivery pipelines. Dynamic languages waxed and waned and when in the ascendant, the distinction of whether a definition was cast in the code or part of the process became indistinct. J2EE, Ruby I'm looking at you. Languages with build systems would look jealously as systems where "it just worked". And I assert that in some important cases - these distinctions really mattered, and were not just aesthetic choices of languages.


